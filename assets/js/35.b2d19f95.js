(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{465:function(s,n,a){"use strict";a.r(n);var p=a(24),l=Object(p.a)({},function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("本文基于 webpack 4 和 babel 7，Mac OS，VS Code")])]),s._v(" "),a("p",[s._v("小程序开发现状：")]),s._v(" "),a("p",[s._v("多端框架(Mpvue, Taro)崛起，但限制了原生小程序的能力。")]),s._v(" "),a("p",[s._v("我司在使用一段时间多端开发框架后，决定回退到原生方案，除了多端框架对原生能力有所限制外，最重要的是，我们只需要一个微信小程序，并不需要跨端。")]),s._v(" "),a("p",[s._v("程序虽小，但需要长期维护，多人维护，因此规范的工程化实践就很重要了。本系列文章分上下两篇，上篇主要讲 webpack, babel, 环境配置，下篇主要讲 Typescript, EsLint, 单元测试，CI / CD。")]),s._v(" "),a("p",[a("strong",[s._v("通过本文，你将学会使用如何使用前端工程技术来开发原生小程序：")])]),s._v(" "),a("ul",[a("li",[s._v("webpack 基础配置以及高级配置")]),s._v(" "),a("li",[s._v("webpack 构建流程，这是编写 webpack 插件的基础")]),s._v(" "),a("li",[s._v("编写 webpack 插件，核心源码不到 50 行，使得小程序开发支持 npm")]),s._v(" "),a("li",[s._v("为你讲述 webpack 插件中关键代码的作用，而不仅仅是提供源码")]),s._v(" "),a("li",[s._v("优化 webpack 配置，剔除不必要的代码，减少包体积")]),s._v(" "),a("li",[s._v("支持 sass 等 css 预处理器")])]),s._v(" "),a("h2",{attrs:{id:"微信小程序官方对-npm-的支持程度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微信小程序官方对-npm-的支持程度","aria-hidden":"true"}},[s._v("#")]),s._v(" 微信小程序官方对 npm 的支持程度")]),s._v(" "),a("p",[s._v("这也是作者为什么要花大力气学习如何编写 webpack 插件，使得小程序可以像 Web 应用那样支持 npm 的缘故。不得不说，这也是一个学习编写 webpack 插件的契机。")]),s._v(" "),a("p",[s._v("先让我们来吐槽官方对 npm 的支持。")]),s._v(" "),a("p",[s._v("打开微信开发者工具 -> 项目 -> 新建项目，使用测试号创建一个小程序项目")]),s._v(" "),a("p",[s._v("通过终端，初始化 npm")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('npm init --yes\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("可以看到，我们的项目根目录下，生成了一个 package.json 文件")]),s._v(" "),a("p",[s._v("现在让我们通过 npm 引入一些依赖，首先是大名鼎鼎的 moment 和 lodash")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('npm i moment lodash\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("点击微信开发者工具中的菜单栏：工具 -> 构建 npm")]),s._v(" "),a("p",[s._v("可以看到，在我们项目的根目录下，生成了一个叫 miniprogram_npm 的目录")]),s._v(" "),a("p",[s._v("修改 app.js，添加如下内容")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// app.js\n<span class="hljs-addition">+ import moment from \'moment\';</span>\nApp({\n  onLaunch: function () {\n<span class="hljs-addition">+    console.log(\'-----------------------------------------------x\');</span>\n<span class="hljs-addition">+    let sFromNowText = moment(new Date().getTime() - 360000).fromNow();</span>\n<span class="hljs-addition">+    console.log(sFromNowText);</span>\n  }\n})\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("并保存，可以看到微信开发者工具控制台输出：")]),s._v(" "),a("p",[s._v("再来测试下 lodash，修改 app.js，添加如下内容")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// app.js\n<span class="hljs-addition">+ import { camelCase } from \'lodash\';</span>\nApp({\n  onLaunch: function () {\n<span class="hljs-addition">+    console.log(camelCase(\'OnLaunch\'));</span>\n  }\n})\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("保存，然后出错了")]),s._v(" "),a("p",[s._v("然后作者又尝试了 rxjs 这个库，也同样失败了。查阅了一些资料，说是要把 rxjs 的源码 clone 下来编译，并将编译结果复制到 miniprogram_npm 这个文件夹。尝试了下，确实可行。 "),a("strong",[s._v("但这种使用 npm 的方式也实在是太奇葩了吧")]),s._v("，太反人类了，不是我们熟悉的味道。")]),s._v(" "),a("h2",{attrs:{id:"创建-webpack-化的小程序项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建-webpack-化的小程序项目","aria-hidden":"true"}},[s._v("#")]),s._v(" 创建 webpack 化的小程序项目")]),s._v(" "),a("p",[s._v("先把 app.js 中新增的代码移除")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// app.js\n<span class="hljs-deletion">- import moment from \'moment\';</span>\n<span class="hljs-deletion">- import { camelCase } from \'lodash\';</span>\nApp({\n  onLaunch: function () {\n<span class="hljs-deletion">-    console.log(\'-----------------------------------------------x\');</span>\n<span class="hljs-deletion">-    let sFromNowText = moment(new Date().getTime() - 360000).fromNow();</span>\n<span class="hljs-deletion">-    console.log(sFromNowText);</span>\n<span class="hljs-deletion">-    console.log(camelCase(\'OnLaunch\'));</span>\n  }\n})\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("删掉 miniprogram_npm 这个文件夹，这真是个异类。")]),s._v(" "),a("p",[s._v("新建文件夹 src，把 pages, utils, app.js, app.json, app.wxss, sitemap.json 这几个文件(夹)移动进去")]),s._v(" "),a("p",[s._v("安装 webpack 和 webpack-cli")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('npm i --save-dev webpack webpack-cli copy-webpack-plugin clean-webpack-plugin\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在根目录下，新建 webpack.config.js 文件，添加如下内容")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<span class="hljs-keyword">const</span> { resolve } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'copy-webpack-plugin\'</span>)\n<span class="hljs-keyword">const</span> { CleanWebpackPlugin } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'clean-webpack-plugin\'</span>)\n\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">context</span>: resolve(<span class="hljs-string">\'src\'</span>),\n  <span class="hljs-attr">entry</span>: <span class="hljs-string">\'./app.js\'</span>,\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">path</span>: resolve(<span class="hljs-string">\'dist\'</span>),\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">\'[name].js\'</span>,\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> CleanWebpackPlugin({\n      <span class="hljs-attr">cleanStaleWebpackAssets</span>: <span class="hljs-literal">false</span>,\n    }),\n    <span class="hljs-keyword">new</span> CopyWebpackPlugin([\n      {\n        <span class="hljs-attr">from</span>: <span class="hljs-string">\'**/*\'</span>,\n        <span class="hljs-attr">to</span>: <span class="hljs-string">\'./\'</span>,\n      },\n    ]),\n  ],\n  <span class="hljs-attr">mode</span>: <span class="hljs-string">\'none\'</span>,\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("修改 project.config.json 文件，指明小程序的入口")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// project.config.json\n{\n"description": "&#x9879;&#x76EE;&#x914D;&#x7F6E;&#x6587;&#x4EF6;",\n<span class="hljs-addition">+  "miniprogramRoot": "dist/",</span>\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在终端输入 npx webpack。")]),s._v(" "),a("p",[s._v("可以看到，在小程序开发者工具的模拟器中，我们的小程序刷新了，而且控制台也没有错误提示。")]),s._v(" "),a("p",[s._v("在我们项目的根目录中，生成了一个叫 dist 的文件夹，里面的内容和 src 中一模一样，除了多了个 main.js 文件。")]),s._v(" "),a("p",[s._v("对 webpack 有所了解的同学都知道，这是 webpack 化项目的经典结构")]),s._v(" "),a("p",[s._v("如果你对 webpack 从不了解，那么此时你应该去阅读以下文档，直到你弄明白为什么会多了个 main.js 文件。")]),s._v(" "),a("p",[s._v("在上面的例子中，我们只是简单地将 src 中的文件原封不动地复制到 dist 中，并且让微信开发者工具感知到，dist 中才是我们要发布的代码。")]),s._v(" "),a("p",[a("strong",[s._v("这是重要的一步，因为我们搭建了一个 webpack 化的小程序项目。")])]),s._v(" "),a("p",[s._v("我们使用 npm，主要是为了解决 js 代码的依赖问题，那么 js 交给 webpack 来处理，其它文件诸如 .json, .wxml, .wxss 直接复制就好了，这么想，事情就会简单很多。")]),s._v(" "),a("p",[s._v("如果你对 webpack 已有基本了解，那么此时，你应该理解小程序是个多页面应用程序，它有多个入口。")]),s._v(" "),a("p",[s._v("下面，让我们修改 webpack.config.js 来配置入口")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("<span class=\"hljs-deletion\">-  entry: './app.js'</span>\n<span class=\"hljs-addition\">+  entry: {</span>\n<span class=\"hljs-addition\">+    'app'              : './app.js',</span>\n<span class=\"hljs-addition\">+    'pages/index/index': './pages/index/index.js',</span>\n<span class=\"hljs-addition\">+    'pages/logs/logs'  : './pages/logs/logs.js'</span>\n<span class=\"hljs-addition\">+  },</span>\n<span class=\"copy-code-btn\">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n")])])]),a("p",[s._v("webpack 需要借助 babel 来处理 js，因此 babel 登场。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('npm i  @babel/core @babel/preset-env babel-loader --save-dev\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在根目录创建 .babelrc 文件，添加如下内容")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n{\n  <span class="hljs-string">"presets"</span>: [<span class="hljs-string">"@babel/env"</span>]\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("修改 webpack.config.js，使用 babel-loader 来处理 js 文件")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('module.exports = {\n<span class="hljs-addition">+  module: {</span>\n<span class="hljs-addition">+    rules: [</span>\n<span class="hljs-addition">+      {</span>\n<span class="hljs-addition">+         test: /\\.js$/,</span>\n<span class="hljs-addition">+         use: \'babel-loader\'</span>\n<span class="hljs-addition">+       }</span>\n<span class="hljs-addition">+     ]</span>\n<span class="hljs-addition">+   },</span>\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("从 src 复制文件到 dist 时，排除 js 文件")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("new CopyWebpackPlugin([\n  {\n    from: '**/*',\n    to: './',\n<span class=\"hljs-addition\">+   ignore: ['**/*.js']</span>\n  }\n])\n<span class=\"copy-code-btn\">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n")])])]),a("p",[s._v("此时，webpack.config.js 文件看起来是这样的：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<span class="hljs-keyword">const</span> { resolve } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'copy-webpack-plugin\'</span>)\n<span class="hljs-keyword">const</span> { CleanWebpackPlugin } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'clean-webpack-plugin\'</span>)\n\n<span class="hljs-built_in">module</span>.exports = {\n  <span class="hljs-attr">context</span>: resolve(<span class="hljs-string">\'src\'</span>),\n  <span class="hljs-attr">entry</span>: {\n    <span class="hljs-attr">app</span>: <span class="hljs-string">\'./app.js\'</span>,\n    <span class="hljs-string">\'pages/index/index\'</span>: <span class="hljs-string">\'./pages/index/index.js\'</span>,\n    <span class="hljs-string">\'pages/logs/logs\'</span>: <span class="hljs-string">\'./pages/logs/logs.js\'</span>,\n  },\n  <span class="hljs-attr">output</span>: {\n    <span class="hljs-attr">path</span>: resolve(<span class="hljs-string">\'dist\'</span>),\n    <span class="hljs-attr">filename</span>: <span class="hljs-string">\'[name].js\'</span>,\n  },\n  <span class="hljs-attr">module</span>: {\n    <span class="hljs-attr">rules</span>: [\n      {\n        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\\.js$/</span>,\n        <span class="hljs-attr">use</span>: <span class="hljs-string">\'babel-loader\'</span>,\n      },\n    ],\n  },\n  <span class="hljs-attr">plugins</span>: [\n    <span class="hljs-keyword">new</span> CleanWebpackPlugin({\n      <span class="hljs-attr">cleanStaleWebpackAssets</span>: <span class="hljs-literal">false</span>,\n    }),\n    <span class="hljs-keyword">new</span> CopyWebpackPlugin([\n      {\n        <span class="hljs-attr">from</span>: <span class="hljs-string">\'**/*\'</span>,\n        <span class="hljs-attr">to</span>: <span class="hljs-string">\'./\'</span>,\n        <span class="hljs-attr">ignore</span>: [<span class="hljs-string">\'**/*.js\'</span>],\n      },\n    ]),\n  ],\n  <span class="hljs-attr">mode</span>: <span class="hljs-string">\'none\'</span>,\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("执行 "),a("code",[s._v("npx webpack")])]),s._v(" "),a("p",[s._v("可以看到，在 dist 文件夹中，main.js 不见了，同时消失的还有 utils 整个文件夹，因为 utils/util.js 已经被合并到依赖它的 pages/logs/logs.js 文件中去了。")]),s._v(" "),a("blockquote",[a("p",[s._v("为什么 main.js 会不见了呢？")])]),s._v(" "),a("p",[s._v("可以看到，在小程序开发者工具的模拟器中，我们的小程序刷新了，而且控制台也没有错误提示。")]),s._v(" "),a("p",[s._v("把下面代码添加回 app.js 文件，看看效果如何？")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// app.js\n<span class="hljs-addition">+ import moment from \'moment\';</span>\n<span class="hljs-addition">+ import { camelCase } from \'lodash\';</span>\nApp({\n  onLaunch: function () {\n<span class="hljs-addition">+    console.log(\'-----------------------------------------------x\');</span>\n<span class="hljs-addition">+    let sFromNowText = moment(new Date().getTime() - 360000).fromNow();</span>\n<span class="hljs-addition">+    console.log(sFromNowText);</span>\n<span class="hljs-addition">+    console.log(camelCase(\'OnLaunch\'));</span>\n  }\n})\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("可以看到，不管是 moment 还是 lodash, 都能正常工作。")]),s._v(" "),a("p",[a("strong",[s._v("这是重要的里程碑的一步，因为我们终于能够正常地使用 npm 了。")])]),s._v(" "),a("p",[s._v("而此时，我们还没有开始写 webpack 插件。")]),s._v(" "),a("p",[s._v("如果你有留意，在执行 "),a("code",[s._v("npx webpack")]),s._v(" 命令时，终端会输出以下信息")]),s._v(" "),a("p",[s._v("生成的 app.js 文件居然有 1M 那么大，要知道，小程序有 2M 的大小限制，这个不用担心，稍后我们通过 webpack 配置来优化它。")]),s._v(" "),a("p",[s._v("而现在，我们开始写 webpack 插件。")]),s._v(" "),a("p",[s._v("前面，我们通过以下方式来配置小程序的入口，")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('entry: {\n  <span class="hljs-string">\'app\'</span>: <span class="hljs-string">\'./app.js\'</span>,\n  <span class="hljs-string">\'pages/index/index\'</span>: <span class="hljs-string">\'./pages/index/index.js\'</span>,\n  <span class="hljs-string">\'pages/logs/logs\'</span>: <span class="hljs-string">\'./pages/logs/logs.js\'</span>,\n},\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("这实在是太丑陋啦，这意味着每写一个 page 或 component，就得配置一次，我们写个 webpack 插件来处理这件事情。")]),s._v(" "),a("p",[s._v("首先安装一个可以替换文件扩展名的依赖")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('npm i --save-dev replace-ext\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在项目根目录中创建一个叫 plugin 的文件夹，在里面创建一个叫 MinaWebpackPlugin.js 的文件，内容如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-keyword">const</span> SingleEntryPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack/lib/SingleEntryPlugin\'</span>)\n<span class="hljs-keyword">const</span> MultiEntryPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack/lib/MultiEntryPlugin\'</span>)\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n<span class="hljs-keyword">const</span> replaceExt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'replace-ext\'</span>)\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">itemToPlugin</span>(<span class="hljs-params">context, item, name</span>) </span>{\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiEntryPlugin(context, item, name)\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SingleEntryPlugin(context, item, name)\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inflateEntries</span>(<span class="hljs-params">entries = [], dirname, entry</span>) </span>{\n  <span class="hljs-keyword">const</span> configFile = replaceExt(entry, <span class="hljs-string">\'.json\'</span>)\n  <span class="hljs-keyword">const</span> content = fs.readFileSync(configFile, <span class="hljs-string">\'utf8\'</span>)\n  <span class="hljs-keyword">const</span> config = <span class="hljs-built_in">JSON</span>.parse(content)\n\n  ;[<span class="hljs-string">\'pages\'</span>, <span class="hljs-string">\'usingComponents\'</span>].forEach(<span class="hljs-function"><span class="hljs-params">key</span> =></span> {\n    <span class="hljs-keyword">const</span> items = config[key]\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> items === <span class="hljs-string">\'object\'</span>) {\n      <span class="hljs-built_in">Object</span>.values(items).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> inflateEntries(entries, dirname, item))\n    }\n  })\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inflateEntries</span>(<span class="hljs-params">entries, dirname, entry</span>) </span>{\n  entry = path.resolve(dirname, entry)\n  <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span> && !entries.includes(entry)) {\n    entries.push(entry)\n    _inflateEntries(entries, path.dirname(entry), entry)\n  }\n}\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinaWebpackPlugin</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.entries = []\n  }\n\n  apply(compiler) {\n    <span class="hljs-keyword">const</span> { context, entry } = compiler.options\n\n    inflateEntries(<span class="hljs-keyword">this</span>.entries, context, entry)\n\n    compiler.hooks.entryOption.tap(<span class="hljs-string">\'MinaWebpackPlugin\'</span>, () => {\n      <span class="hljs-keyword">this</span>.entries\n\n        .map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> replaceExt(item, <span class="hljs-string">\'.js\'</span>))\n\n        .map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> path.relative(context, item))\n\n        .forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> itemToPlugin(context, <span class="hljs-string">\'./\'</span> + item, replaceExt(item, <span class="hljs-string">\'\'</span>)).apply(compiler))\n\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    })\n  }\n}\n\n<span class="hljs-built_in">module</span>.exports = MinaWebpackPlugin\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("该插件所做的事情，和我们手动配置 entry 所做的一模一样，通过代码分析 .json 文件，找到所有可能的入口文件，添加到 webpack。")]),s._v(" "),a("p",[s._v("修改 webpack.config.js，应用该插件")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("<span class=\"hljs-addition\">+ const MinaWebpackPlugin = require('./plugin/MinaWebpackPlugin');</span>\n\nmodule.exports = {\n   context: resolve('src'),\n<span class=\"hljs-deletion\">-  entry: {</span>\n<span class=\"hljs-deletion\">-    'app'              : './app.js',</span>\n<span class=\"hljs-deletion\">-    'pages/index/index': './pages/index/index.js',</span>\n<span class=\"hljs-deletion\">-    'pages/logs/logs'  : './pages/logs/logs.js'</span>\n<span class=\"hljs-deletion\">-  },</span>\n<span class=\"hljs-addition\">+  entry: './app.js',</span>\n\n   plugins: [\n<span class=\"hljs-addition\">+    new MinaWebpackPlugin()</span>\n   ],\n   mode: 'none'\n};\n<span class=\"copy-code-btn\">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n")])])]),a("p",[s._v("执行 "),a("code",[s._v("npx webpack")]),s._v("，顺利通过！")]),s._v(" "),a("p",[s._v("上面的插件代码是否读得不太懂？因为我们还没有了解 webpack 的工作流程。")]),s._v(" "),a("h2",{attrs:{id:"webpack-构建流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-构建流程","aria-hidden":"true"}},[s._v("#")]),s._v(" webpack 构建流程")]),s._v(" "),a("p",[s._v("编程就是处理输入和输出的技术，webpack 好比一台机器，entry 就是原材料，经过若干道工序（plugin, loader），产生若干中间产物 (dependency, module, chunk, assets)，最终将产品放到 dist 文件夹中。")]),s._v(" "),a("p",[s._v("我们在讲解 webpack 流程时，对理解我们将要编写的小程序 webpack 插件有帮助的地方会详情讲解，其它地方会简略，如果希望对 webpack 流程有比较深刻的理解，还需要阅读其它资料以及源码。")]),s._v(" "),a("p",[s._v("当我们执行 "),a("code",[s._v("npx webpack")]),s._v(" 这样的命令时，webpack 会解析 webpack.config.js 文件，以及命令行参数，将其中的配置和参数合成一个 options 对象，然后调用 "),a("a",{attrs:{href:"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fblob%2Fmaster%2Flib%2Fwebpack.js%23L25",target:"_blank",rel:"noopener noreferrer"}},[s._v("webpack 函数"),a("OutboundLink")],1)]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-function">(<span class="hljs-params">options, callback</span>) =></span> {\n  <span class="hljs-keyword">let</span> compiler\n\n  options = <span class="hljs-keyword">new</span> WebpackOptionsDefaulter().process(options)\n\n  compiler = <span class="hljs-keyword">new</span> Compiler(options.context)\n  compiler.options = options\n\n  <span class="hljs-keyword">if</span> (options.plugins && <span class="hljs-built_in">Array</span>.isArray(options.plugins)) {\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> plugin <span class="hljs-keyword">of</span> options.plugins) {\n      plugin.apply(compiler)\n    }\n  }\n\n  compiler.options = <span class="hljs-keyword">new</span> WebpackOptionsApply().process(options, compiler)\n\n  compiler.run(callback)\n  <span class="hljs-keyword">return</span> compiler\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在这个函数中，创建了 compiler 对象，并将完整的配置参数 options 保存到 compiler 对象中，最后调用了 compiler 的 run 方法。")]),s._v(" "),a("p",[s._v("compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。可以使用 compiler 来访问 webpack 的主环境。")]),s._v(" "),a("p",[s._v("从以上源码可以看到，用户配置的 plugin 先于内置的 plugin 被应用。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebpackOptionsApply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OptionsApply</span> </span>{\n  process(options, compiler) {\n    <span class="hljs-keyword">new</span> EntryOptionPlugin().apply(compiler)\n    compiler.hooks.entryOption.call(options.context, options.entry)\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("WebpackOptionsApply 应用了 EntryOptionPlugin 插件并立即触发了 compiler 的 entryOption 事件钩子，")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fblob%2Fmaster%2Flib%2FCompiler.js%23L98",target:"_blank",rel:"noopener noreferrer"}},[s._v("entryOption"),a("OutboundLink")],1),s._v(" 是个 SyncBailHook, 意味着只要有一个插件返回了 true, 注册在这个钩子上的后续插件代码，将不会被调用。我们在编写小程序插件时，用到了这个特性。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-keyword">const</span> itemToPlugin = <span class="hljs-function">(<span class="hljs-params">context, item, name</span>) =></span> {\n  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) {\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiEntryPlugin(context, item, name)\n  }\n  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SingleEntryPlugin(context, item, name)\n}\n\n<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryOptionPlugin</span> </span>{\n  apply(compiler) {\n    compiler.hooks.entryOption.tap(<span class="hljs-string">\'EntryOptionPlugin\'</span>, (context, entry) => {\n      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> entry === <span class="hljs-string">\'string\'</span> || <span class="hljs-built_in">Array</span>.isArray(entry)) {\n\n        itemToPlugin(context, entry, <span class="hljs-string">\'main\'</span>).apply(compiler)\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> entry === <span class="hljs-string">\'object\'</span>) {\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(entry)) {\n          itemToPlugin(context, entry[name], name).apply(compiler)\n        }\n      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> entry === <span class="hljs-string">\'function\'</span>) {\n        <span class="hljs-keyword">new</span> DynamicEntryPlugin(context, entry).apply(compiler)\n      }\n\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    })\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("EntryOptionPlugin 中的代码非常简单，它主要是根据 entry 的类型，把工作委托给 "),a("code",[s._v("SingleEntryPlugin")]),s._v(", "),a("code",[s._v("MultiEntryPlugin")]),s._v(" 以及 "),a("code",[s._v("DynamicEntryPlugin")]),s._v("。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleEntryPlugin</span> </span>{\n  <span class="hljs-keyword">constructor</span>(context, entry, name) {\n    <span class="hljs-keyword">this</span>.context = context\n    <span class="hljs-keyword">this</span>.entry = entry\n    <span class="hljs-keyword">this</span>.name = name\n  }\n\n  apply(compiler) {\n\n    compiler.hooks.compilation.tap(<span class="hljs-string">\'SingleEntryPlugin\'</span>, (compilation, { normalModuleFactory }) => {\n\n      compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory)\n    })\n\n    compiler.hooks.make.tapAsync(<span class="hljs-string">\'SingleEntryPlugin\'</span>, (compilation, callback) => {\n      <span class="hljs-keyword">const</span> { entry, name, context } = <span class="hljs-keyword">this</span>\n\n      <span class="hljs-keyword">const</span> dep = SingleEntryPlugin.createDependency(entry, name)\n\n      compilation.addEntry(context, dep, name, callback)\n    })\n  }\n\n  <span class="hljs-keyword">static</span> createDependency(entry, name) {\n    <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> SingleEntryDependency(entry)\n    dep.loc = { name }\n    <span class="hljs-keyword">return</span> dep\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("那么 make 事件又是如何被触发的呢？当 WebpackOptionsApply.process 执行完后，将会调用 compiler 的 run 方法，而 run 方法又调用了 compile 方法，在里面触发了 make 事件钩子，如下面代码所示：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-function">(<span class="hljs-params">options, callback</span>) =></span> {\n\n  compiler.options = <span class="hljs-keyword">new</span> WebpackOptionsApply().process(options, compiler)\n\n  compiler.run(callback)\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compiler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n  run(callback) {\n    <span class="hljs-keyword">const</span> onCompiled = <span class="hljs-function">(<span class="hljs-params">err, compilation</span>) =></span> {\n\n    }\n\n    <span class="hljs-keyword">this</span>.compile(onCompiled)\n  }\n\n  compile(callback) {\n    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.newCompilationParams()\n    <span class="hljs-keyword">this</span>.hooks.compile.call(params)\n\n    <span class="hljs-keyword">const</span> compilation = <span class="hljs-keyword">this</span>.newCompilation(params)\n\n    <span class="hljs-keyword">this</span>.hooks.make.callAsync(compilation, err => {\n\n    })\n  }\n\n  newCompilation(params) {\n    <span class="hljs-keyword">const</span> compilation = <span class="hljs-keyword">this</span>.createCompilation()\n\n    <span class="hljs-keyword">this</span>.hooks.compilation.call(compilation, params)\n    <span class="hljs-keyword">return</span> compilation\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("webpack 函数创建了 compiler 对象，而 compiler 对象创建了 compilation 对象。compiler 对象代表了完整的 webpack 环境配置，而 compilatoin 对象则负责整个打包过程，它存储着打包过程的中间产物。compiler 对象触发 make 事件后，控制权就会转移到 compilation，compilation 通过调用 addEntry 方法，开始了编译与构建主流程。")]),s._v(" "),a("p",[s._v("现在，我们有足够的知识理解之前编写的 webpack 插件了")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinaWebpackPlugin</span> </span>{\n  <span class="hljs-keyword">constructor</span>() {\n    <span class="hljs-keyword">this</span>.entries = []\n  }\n\n  apply(compiler) {\n    <span class="hljs-keyword">const</span> { context, entry } = compiler.options\n    inflateEntries(<span class="hljs-keyword">this</span>.entries, context, entry)\n\n    compiler.hooks.entryOption.tap(pluginName, () => {\n      <span class="hljs-keyword">this</span>.entries\n        .map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> replaceExt(item, <span class="hljs-string">\'.js\'</span>))\n        .map(<span class="hljs-function"><span class="hljs-params">item</span> =></span> path.relative(context, item))\n\n        .forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> itemToPlugin(context, <span class="hljs-string">\'./\'</span> + item, replaceExt(item, <span class="hljs-string">\'\'</span>)).apply(compiler))\n\n      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>\n    })\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("blockquote",[a("p",[s._v("为了动态注册入口，除了可以监听 entryOption 这个钩子外，我们还可以监听 make 这个钩子来达到同样的目的。")])]),s._v(" "),a("p",[a("code",[s._v("addEntry")]),s._v(" 中调用了私有方法 "),a("code",[s._v("_addModuleChain")]),s._v(" ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compilation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n\n  addEntry(context, entry, name, callback) {\n    <span class="hljs-keyword">this</span>._addModuleChain(context, entry, onModule, callbak)\n  }\n\n  _addModuleChain(context, dependency, onModule, callback) {\n    <span class="hljs-keyword">const</span> Dep = dependency.constructor\n\n    <span class="hljs-keyword">const</span> moduleFactory = <span class="hljs-keyword">this</span>.dependencyFactories.get(Dep)\n\n    moduleFactory.create()\n  }\n\n  buildModule(<span class="hljs-built_in">module</span>, optional, origin, dependencies, thisCallback) {\n\n    <span class="hljs-built_in">module</span>.build()\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("在所有的模块构建完成后，webpack 调用 "),a("code",[s._v("compilation.seal")]),s._v(" 方法，开始生成 chunks。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compiler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n  compile(callback) {\n    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.newCompilationParams()\n    <span class="hljs-keyword">this</span>.hooks.compile.call(params)\n\n    <span class="hljs-keyword">const</span> compilation = <span class="hljs-keyword">this</span>.newCompilation(params)\n\n    <span class="hljs-keyword">this</span>.hooks.make.callAsync(compilation, err => {\n\n      compilation.seal(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {})\n    })\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[a("code",[s._v("seal")]),s._v(" 方法包含了优化、分块、哈希，编译停止接收新模块，开始生成 chunks。此阶段依赖了一些 webpack 内部插件对 module 进行优化，为本次构建生成的 chunk 加入 hash 等。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compilation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n  seal(callback) {\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> preparedEntrypoint <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>._preparedEntrypoints) {\n      <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = preparedEntrypoint.module\n      <span class="hljs-keyword">const</span> name = preparedEntrypoint.name\n\n      <span class="hljs-keyword">const</span> chunk = <span class="hljs-keyword">this</span>.addChunk(name)\n\n      <span class="hljs-keyword">const</span> entrypoint = <span class="hljs-keyword">new</span> Entrypoint(name)\n      entrypoint.setRuntimeChunk(chunk)\n      entrypoint.addOrigin(<span class="hljs-literal">null</span>, name, preparedEntrypoint.request)\n\n      <span class="hljs-keyword">this</span>.namedChunkGroups.set(name, entrypoint)\n      <span class="hljs-keyword">this</span>.entrypoints.set(name, entrypoint)\n      <span class="hljs-keyword">this</span>.chunkGroups.push(entrypoint)\n\n      GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk)\n\n      GraphHelpers.connectChunkAndModule(chunk, <span class="hljs-built_in">module</span>)\n\n      chunk.entryModule = <span class="hljs-built_in">module</span>\n      chunk.name = name\n\n      <span class="hljs-keyword">this</span>.assignDepth(<span class="hljs-built_in">module</span>)\n    }\n\n    <span class="hljs-keyword">this</span>.processDependenciesBlocksForChunkGroups(<span class="hljs-keyword">this</span>.chunkGroups.slice())\n\n    <span class="hljs-keyword">while</span> (\n      <span class="hljs-keyword">this</span>.hooks.optimizeChunksBasic.call(<span class="hljs-keyword">this</span>.chunks, <span class="hljs-keyword">this</span>.chunkGroups) ||\n      <span class="hljs-keyword">this</span>.hooks.optimizeChunks.call(<span class="hljs-keyword">this</span>.chunks, <span class="hljs-keyword">this</span>.chunkGroups) ||\n      <span class="hljs-keyword">this</span>.hooks.optimizeChunksAdvanced.call(<span class="hljs-keyword">this</span>.chunks, <span class="hljs-keyword">this</span>.chunkGroups)\n    ) {\n\n    }\n    <span class="hljs-keyword">this</span>.hooks.afterOptimizeChunks.call(<span class="hljs-keyword">this</span>.chunks, <span class="hljs-keyword">this</span>.chunkGroups)\n\n    <span class="hljs-keyword">this</span>.createHash()\n\n    <span class="hljs-keyword">this</span>.hooks.beforeChunkAssets.call()\n\n    <span class="hljs-keyword">this</span>.createChunkAssets()\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("Compilation 在实例化的时候，就会同时实例化三个对象：MainTemplate, ChunkTemplate，ModuleTemplate。这三个对象是用来渲染 chunk 对象，得到最终代码的模板。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compilation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n\n  createChunkAssets() {\n\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-keyword">this</span>.chunks.length; i++) {\n\n      <span class="hljs-keyword">const</span> template = chunk.hasRuntime() ? <span class="hljs-keyword">this</span>.mainTemplate : <span class="hljs-keyword">this</span>.chunkTemplate\n    }\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("接下来我们看 MainTemplate 是如何渲染 chunk 的。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTemplate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n  <span class="hljs-keyword">constructor</span>(outputOptions) {\n    <span class="hljs-keyword">super</span>()\n    <span class="hljs-keyword">this</span>.hooks = {\n      <span class="hljs-attr">bootstrap</span>: <span class="hljs-keyword">new</span> SyncWaterfallHook([<span class="hljs-string">\'source\'</span>, <span class="hljs-string">\'chunk\'</span>, <span class="hljs-string">\'hash\'</span>, <span class="hljs-string">\'moduleTemplate\'</span>, <span class="hljs-string">\'dependencyTemplates\'</span>]),\n      <span class="hljs-attr">render</span>: <span class="hljs-keyword">new</span> SyncWaterfallHook([<span class="hljs-string">\'source\'</span>, <span class="hljs-string">\'chunk\'</span>, <span class="hljs-string">\'hash\'</span>, <span class="hljs-string">\'moduleTemplate\'</span>, <span class="hljs-string">\'dependencyTemplates\'</span>]),\n      <span class="hljs-attr">renderWithEntry</span>: <span class="hljs-keyword">new</span> SyncWaterfallHook([<span class="hljs-string">\'source\'</span>, <span class="hljs-string">\'chunk\'</span>, <span class="hljs-string">\'hash\'</span>]),\n    }\n\n    <span class="hljs-keyword">this</span>.hooks.render.tap(<span class="hljs-string">\'MainTemplate\'</span>, (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {\n      <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">new</span> ConcatSource()\n\n      source.add(<span class="hljs-keyword">new</span> PrefixSource(<span class="hljs-string">\'/******/\'</span>, bootstrapSource))\n\n      source.add(<span class="hljs-keyword">this</span>.hooks.modules.call(<span class="hljs-keyword">new</span> RawSource(<span class="hljs-string">\'\'</span>), chunk, hash, moduleTemplate, dependencyTemplates))\n\n      <span class="hljs-keyword">return</span> source\n    })\n  }\n\n  render(hash, chunk, moduleTemplate, dependencyTemplates) {\n\n    <span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">this</span>.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates)\n\n    <span class="hljs-keyword">let</span> source = <span class="hljs-keyword">this</span>.hooks.render.call(\n\n      <span class="hljs-keyword">new</span> OriginalSource(Template.prefix(buf, <span class="hljs-string">\' \\t\'</span>) + <span class="hljs-string">\'\\n\'</span>, <span class="hljs-string">\'webpack/bootstrap\'</span>),\n      chunk,\n      hash,\n      moduleTemplate,\n      dependencyTemplates,\n    )\n\n    <span class="hljs-keyword">if</span> (chunk.hasEntryModule()) {\n\n      source = <span class="hljs-keyword">this</span>.hooks.renderWithEntry.call(source, chunk, hash)\n    }\n    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcatSource(source, <span class="hljs-string">\';\'</span>)\n  }\n\n  renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {\n    <span class="hljs-keyword">const</span> buf = []\n\n    buf.push(<span class="hljs-keyword">this</span>.hooks.bootstrap.call(<span class="hljs-string">\'\'</span>, chunk, hash, moduleTemplate, dependencyTemplates))\n    <span class="hljs-keyword">return</span> buf\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("所谓渲染就是生成代码的过程，代码就是字符串，渲染就是拼接和替换字符串的过程。")]),s._v(" "),a("p",[s._v("最终渲染好的代码会存放在 compilation 的 assets 属性中。")]),s._v(" "),a("p",[s._v("最后，webpack 调用 Compiler 的 emitAssets 方法，按照 output 中的配置项将文件输出到了对应的 path 中，从而结束整个打包过程。")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compiler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tapable</span> </span>{\n  run(callback) {\n    <span class="hljs-keyword">const</span> onCompiled = <span class="hljs-function">(<span class="hljs-params">err, compilation</span>) =></span> {\n\n      <span class="hljs-keyword">this</span>.emitAssets(compilation, err => {})\n    }\n\n    <span class="hljs-keyword">this</span>.compile(onCompiled)\n  }\n\n  emitAssets(compilation, callback) {\n    <span class="hljs-keyword">const</span> emitFiles = <span class="hljs-function"><span class="hljs-params">err</span> =></span> {}\n\n    <span class="hljs-keyword">this</span>.hooks.emit.callAsync(compilation, err => {\n      outputPath = compilation.getPath(<span class="hljs-keyword">this</span>.outputPath)\n      <span class="hljs-keyword">this</span>.outputFileSystem.mkdirp(outputPath, emitFiles)\n    })\n  }\n\n  compile(onCompiled) {\n    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.newCompilationParams()\n    <span class="hljs-keyword">this</span>.hooks.compile.call(params)\n\n    <span class="hljs-keyword">const</span> compilation = <span class="hljs-keyword">this</span>.newCompilation(params)\n\n    <span class="hljs-keyword">this</span>.hooks.make.callAsync(compilation, err => {\n\n      compilation.seal(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {\n\n        <span class="hljs-keyword">return</span> onCompiled(<span class="hljs-literal">null</span>, compilation)\n      })\n    })\n  }\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("h2",{attrs:{id:"分离-runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分离-runtime","aria-hidden":"true"}},[s._v("#")]),s._v(" 分离 Runtime")]),s._v(" "),a("p",[s._v("现在，回到我们的小程序项目，确保 app.js 已经移除了下列代码")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('// app.js\n<span class="hljs-deletion">- import moment from \'moment\';</span>\n<span class="hljs-deletion">- import { camelCase } from \'lodash\';</span>\nApp({\n  onLaunch: function () {\n<span class="hljs-deletion">-    console.log(\'-----------------------------------------------x\');</span>\n<span class="hljs-deletion">-    let sFromNowText = moment(new Date().getTime() - 360000).fromNow();</span>\n<span class="hljs-deletion">-    console.log(sFromNowText);</span>\n<span class="hljs-deletion">-    console.log(camelCase(\'OnLaunch\'));</span>\n  }\n})\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("执行 "),a("code",[s._v("npx webpack")]),s._v("，观察生成的代码")]),s._v(" "),a("p",[s._v("由 mainTemplate 生成的 webpackBootstrap 代码就是 webpack runtime 的代码，是整个应用的执行起点。moduleTemplate 则把我们的代码包裹在一个模块包装器函数中。")]),s._v(" "),a("p",[s._v("代码行有 "),a("code",[s._v("/******/")]),s._v(" 前缀的表示该行代码由 mainTemplate 生成，有 "),a("code",[s._v("/***/")]),s._v(" 前缀的表示该行代码由 moduleTemplate 生成，没有前缀的就是我们编写的经过 loader 处理后的模块代码。")]),s._v(" "),a("p",[s._v("我们再来看看 dist/logs/logs.js 的代码")]),s._v(" "),a("p",[s._v("可以看到")]),s._v(" "),a("ul",[a("li",[s._v("同样生成了 webpack runtime 代码，")]),s._v(" "),a("li",[s._v("utils/util.js 中的代码被合并到了 dist/logs/logs.js")]),s._v(" "),a("li",[s._v("logs.js 和 util.js 中的代码分别被包裹在模块包装器中")])]),s._v(" "),a("p",[s._v("哪些数字是什么意思呢？它们表示模块的 id。")]),s._v(" "),a("p",[s._v("从上面的代码可以看到，logs.js 通过 "),a("code",[s._v("__webpack_require__(3)")]),s._v(" 导入了 id 为 3 的模块，这正是 util.js。")]),s._v(" "),a("p",[s._v("我们不希望每个入口文件都生成 runtime 代码，而是希望将其抽离到一个单独的文件中，以减少 app 的体积。我们通过"),a("a",{attrs:{href:"https://link.juejin.im?target=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Foptimization%2F%23optimization-runtimechunk",target:"_blank",rel:"noopener noreferrer"}},[s._v("配置 runtimeChunk"),a("OutboundLink")],1),s._v(" 来达到这一目的。")]),s._v(" "),a("p",[s._v("修改 webpack.config.js 文件，添加如下配置")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('module.exports = {\n<span class="hljs-addition">+  optimization: {</span>\n<span class="hljs-addition">+    runtimeChunk: {</span>\n<span class="hljs-addition">+      name: \'runtime\'</span>\n<span class="hljs-addition">+    }</span>\n<span class="hljs-addition">+  },</span>\n  mode: \'none\'\n}\n<span class="copy-code-btn">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n')])])]),a("p",[s._v("执行 "),a("code",[s._v("npx webpack")]),s._v("，")]),s._v(" "),a("p",[s._v("可以看到，在 dist 目录中，生成了名为 runtime.js 的文件")]),s._v(" "),a("p",[s._v("现在我们开看看 dist/app.js")]),s._v(" "),a("p",[s._v("这似乎是要把 app.js 模块存放到全局对象 window 中，但是小程序中并没有 window 对象，只有 wx。我们在 webpack.config.js 中，把全局对象配置为 "),a("code",[s._v("wx")])]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports = {\n  output: {\n    path: resolve('dist'),\n<span class=\"hljs-deletion\">-   filename: '[name].js'</span>\n<span class=\"hljs-addition\">+   filename: '[name].js',</span>\n<span class=\"hljs-addition\">+   globalObject: 'wx'</span>\n  },\n}\n<span class=\"copy-code-btn\">&#x590D;&#x5236;&#x4EE3;&#x7801;</span>\n")])])]),a("p",[s._v("然而，还是有问题，我们的小程序已经跑不起来了")]),s._v(" "),a("p",[s._v("这是因为小程序和 web 应用不一样，web 应用可以通过 ``"),a("script",[s._v('</code> 标签引用 runtime.js，然而小程序却不能这样。</p><p>我们必须让其它模块感知到 runtime.js 的存在，因为 runtime.js 里面是个立即调用函数表达式，所以只要导入 runtime.js 即可。</p><p>我们在 assets 渲染阶段曾经提到过：</p><pre><code class="hljs js copyable">\n<span class="hljs-keyword">if</span> (chunk.hasEntryModule()) {</p>\n<p>source = <span class="hljs-keyword">this</span>.hooks.renderWithEntry.call(source, chunk, hash)\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>之前的 MinaWebpackPlugin 是用来处理 entry 的，这里我们遵循单一职责原则，编写另一个插件来处理 runtime。</p><p>为了方便讲解和学习，我们将其中的代码略作删改，复制到 plugin/MinaRuntimePlugin.js 中</p><pre><code class="hljs js copyable"></p>\n<p><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span> ensurePosix = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'ensure-posix-path\'</span>)\n<span class="hljs-keyword">const</span> { ConcatSource } = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack-sources\'</span>)\n<span class="hljs-keyword">const</span> requiredPath = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'required-path\'</span>)</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isRuntimeExtracted</span>(<span class="hljs-params">compilation</span>) </span>{\n<span class="hljs-keyword">return</span> compilation.chunks.some(<span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span> chunk.isOnlyInitial() &amp;&amp; chunk.hasRuntime() &amp;&amp; !chunk.hasEntryModule())\n}</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">script</span>(<span class="hljs-params">{ dependencies }</span>) </span>{\n<span class="hljs-keyword">return</span> <span class="hljs-string">\';\'</span> + dependencies.map(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> <span class="hljs-string"><code>require(\'&lt;span class=&quot;hljs-subst&quot;&gt;${requiredPath(file)}&lt;/span&gt;\');</code></span>).join(<span class="hljs-string">\'\'</span>)\n}</p>\n<p><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinaRuntimeWebpackPlugin</span> </span>{\n<span class="hljs-keyword">constructor</span>(options = {}) {\n<span class="hljs-keyword">this</span>.runtime = options.runtime || <span class="hljs-string">\'\'</span>\n}</p>\n<p>apply(compiler) {\ncompiler.hooks.compilation.tap(<span class="hljs-string">\'MinaRuntimePlugin\'</span>, compilation =&gt; {\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> template <span class="hljs-keyword">of</span> [compilation.mainTemplate, compilation.chunkTemplate]) {</p>\n<pre><code>    template.hooks.renderWithEntry.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaRuntimePlugin\'&lt;/span&gt;, (source, entry) =&gt; {\n      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!isRuntimeExtracted(compilation)) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Error&lt;/span&gt;(\n          [\n            &lt;span class=&quot;hljs-string&quot;&gt;\'Please reuse the runtime chunk to avoid duplicate loading of javascript files.\'&lt;/span&gt;,\n            &lt;span class=&quot;hljs-string&quot;&gt;&quot;Simple solution: set `optimization.runtimeChunk` to `{ name: \'runtime.js\' }` .&quot;&lt;/span&gt;,\n            &lt;span class=&quot;hljs-string&quot;&gt;\'Detail of `optimization.runtimeChunk`: https://webpack.js.org/configuration/optimization/#optimization-runtimechunk .\'&lt;/span&gt;,\n          ].join(&lt;span class=&quot;hljs-string&quot;&gt;\'\\n\'&lt;/span&gt;),\n        )\n      }\n\n      &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!entry.hasEntryModule()) {\n        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; source\n      }\n\n      &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; dependencies = []\n\n      entry.groupsIterable.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;group&lt;/span&gt; =&gt;&lt;/span&gt; {\n        group.chunks.forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;chunk&lt;/span&gt; =&gt;&lt;/span&gt; {\n\n          &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; filename = ensurePosix(path.relative(path.dirname(entry.name), chunk.name))\n\n          &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (chunk === entry || ~dependencies.indexOf(filename)) {\n            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;\n          }\n          dependencies.push(filename)\n        })\n      })\n\n      source = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConcatSource(script({ dependencies }), source)\n      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; source\n    })\n  }\n})\n</code></pre>\n<p>}\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 webpack.config.js，应用该插件</p><pre><code class="hljs diff copyable">  const MinaWebpackPlugin = require(\'./plugin/MinaWebpackPlugin\');\n<span class="hljs-addition">+ const MinaRuntimePlugin = require(\'./plugin/MinaRuntimePlugin\');</span>\nmodule.exports = {\nplugins: [\nnew MinaWebpackPlugin(),\n<span class="hljs-addition">+     new MinaRuntimePlugin()</span>\n],\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>执行 <code>npx webpack</code>，我们的小程序此时应该能正常跑起来了。</p><p>查看 dist/app.js, dist/pages/index/index.js 等文件，它们的首行都添加了类似 <code>;require(\'./../../runtime\');</code> 的代码。</p><p>到目前为止，我们每修改一次代码，便执行一次 <code>npx webpack</code>，这有些麻烦，能不能让 webpack 检测文件的变化，自动刷新呢？答案是有的。</p><p>webpack 可以以 run 或 watchRun 的方式运行</p><pre><code class="hljs js copyable">\n<span class="hljs-keyword">const</span> webpack = <span class="hljs-function">(<span class="hljs-params">options, callback</span>) =&gt;</span> {\n<span class="hljs-keyword">if</span> (options.watch === <span class="hljs-literal">true</span> || (<span class="hljs-built_in">Array</span>.isArray(options) &amp;&amp; options.some(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o.watch))) {\n<span class="hljs-keyword">const</span> watchOptions = <span class="hljs-built_in">Array</span>.isArray(options) ? options.map(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o.watchOptions || {}) : options.watchOptions || {}</p>\n<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; compiler.watch(watchOptions, callback)\n</code></pre>\n<p>}\ncompiler.run(callback)\n<span class="hljs-keyword">return</span> compiler\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 plugin/MinaWebpackPlugin.js 文件</p><pre><code class="hljs js copyable"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinaWebpackPlugin</span> </span>{\n<span class="hljs-keyword">constructor</span>() {\n<span class="hljs-keyword">this</span>.entries = []\n}</p>\n<p>applyEntry(compiler, done) {\n<span class="hljs-keyword">const</span> { context } = compiler.options\n<span class="hljs-keyword">this</span>.entries\n.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> replaceExt(item, <span class="hljs-string">\'.js\'</span>))\n.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> path.relative(context, item))\n.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> itemToPlugin(context, <span class="hljs-string">\'./\'</span> + item, replaceExt(item, <span class="hljs-string">\'\'</span>)).apply(compiler))\n<span class="hljs-keyword">if</span> (done) {\ndone()\n}\n}</p>\n<p>apply(compiler) {\n<span class="hljs-keyword">const</span> { context, entry } = compiler.options\ninflateEntries(<span class="hljs-keyword">this</span>.entries, context, entry)</p>\n<pre><code>compiler.hooks.entryOption.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, () =&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.applyEntry(compiler)\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n})\n\ncompiler.hooks.watchRun.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, (compiler, done) =&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.applyEntry(compiler, done)\n})\n</code></pre>\n<p>}\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>执行 <code>npx webpack --watch --progress</code> 即可开启 watch 模式，修改源代码并保存，将会重新生成 dist。</p><h2 class="heading">webpack 配置优化</h2><p>webpack 可以帮助我们 ES6 转 ES5，压缩和混淆代码，因此这些事情，不需要微信开发者工具帮我们做了。点击微信开发者工具右上角的<strong>详情</strong>按钮，在项目设置中，反勾选 ES6 转 ES5，上传代码时自动压缩混淆等选项，如图所示：</p><p>修改 src/pages/index/index.js 文件，</p><pre><code class="hljs diff copyable"><span class="hljs-addition">+ const util = require(\'../../utils/util.js\');</span>\n<span class="hljs-addition">+ console.log(util.formatTime(new Date()));</span></p>\n<p>const app = getApp();\n<span class="copy-code-btn">复制代码</span></code></pre><p>执行 <code>npx webpack</code></p><p>可以看到，生成的 dist/pages/index/index.js 和 dist/pages/logs/logs.js 文件都有同样的代码</p><pre><code class="hljs js copyable">😭<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{</p>\n<p><span class="hljs-keyword">var</span> formatTime = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatTime</span>(<span class="hljs-params">date</span>) </span>{\n<span class="hljs-keyword">var</span> year = date.getFullYear()\n<span class="hljs-keyword">var</span> month = date.getMonth() + <span class="hljs-number">1</span>\n<span class="hljs-keyword">var</span> day = date.getDate()\n<span class="hljs-keyword">var</span> hour = date.getHours()\n<span class="hljs-keyword">var</span> minute = date.getMinutes()\n<span class="hljs-keyword">var</span> second = date.getSeconds()\n<span class="hljs-keyword">return</span> [year, month, day].map(formatNumber).join(<span class="hljs-string">\'/\'</span>) + <span class="hljs-string">\' \'</span> + [hour, minute, second].map(formatNumber).join(<span class="hljs-string">\':\'</span>)\n}</p>\n<p><span class="hljs-keyword">var</span> formatNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatNumber</span>(<span class="hljs-params">n</span>) </span>{\nn = n.toString()\n<span class="hljs-keyword">return</span> n[<span class="hljs-number">1</span>] ? n : <span class="hljs-string">\'0\'</span> + n\n}</p>\n<p><span class="hljs-built_in">module</span>.exports = {\n<span class="hljs-attr">formatTime</span>: formatTime,\n}\n})\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 webpack.config.js 文件</p><pre><code class="hljs diff copyable">  optimization: {\n<span class="hljs-addition">+   splitChunks: {</span>\n<span class="hljs-addition">+     chunks: \'all\',</span>\n<span class="hljs-addition">+     name: \'common\',</span>\n<span class="hljs-addition">+     minChunks: 2,</span>\n<span class="hljs-addition">+     minSize: 0,</span>\n<span class="hljs-addition">+   },</span>\nruntimeChunk: {\nname: \'runtime\',\n},\n},\n<span class="copy-code-btn">复制代码</span></code></pre><p>执行 <code>npx webpack</code></p><p>可以看到 dist 目录下生成了一个 common.js 文件，里面有 util.js 的代码，而 dist/pages/index/index.js 和 dist/pages/logs/logs.js 的首行代码则导入了 common 文件：<code>;require(\'./../../runtime\');require(\'./../../common\');</code></p><p>目前，我们通过 <code>npx webpack</code> 生成的代码都是未经过压缩和优化的，稍不注意，就会超过微信 2M 大小的限制。</p><p>请根据文档指引进行配置，这里不作展开。</p><p>下面我们执行 <code>npx webpack --mode=production</code></p><p>可以看到生成的 app.js 文件大小还不到 1KB</p><p>下面，我们引入个大文件</p><p>修改 src/app.js 文件，重新引入 lodash</p><pre><code class="hljs diff copyable">// app.js\n<span class="hljs-addition">+ import { camelCase } from \'lodash\';</span>\nApp({\nonLaunch: function () {\n<span class="hljs-addition">+    console.log(\'-----------------------------------------------x\');</span>\n<span class="hljs-addition">+    console.log(camelCase(\'OnLaunch\'));</span>\n}\n})\n<span class="copy-code-btn">复制代码</span></code></pre><p>执行 <code>npx webpack --mode=production</code>，可以看到 app.js 文件有将近 70 KB 那么大，为了使用 lodash，这代价也太大了。不过幸好有<a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F36280323" rel="nofollow noopener noreferrer">优化方法</a>：</p><p>首先安装以下两个依赖</p><pre><code class="hljs bash copyable">npm i --save-dev babel-plugin-lodash lodash-webpack-plugin\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 webpack.config.js 文件</p><pre><code class="hljs diff copyable">  const MinaRuntimePlugin = require(\'./plugin/MinaRuntimePlugin\');\n<span class="hljs-addition">+ const LodashWebpackPlugin = require(\'lodash-webpack-plugin\');</span></p>\n<p>new MinaRuntimePlugin(),\n<span class="hljs-addition">+ new LodashWebpackPlugin()</span>\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 .babelrc 文件</p><pre><code class="hljs diff copyable">{\n&quot;presets&quot;: [&quot;@babel/env&quot;],\n<span class="hljs-addition">+ &quot;plugins&quot;: [&quot;lodash&quot;]</span>\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>再次执行 <code>npx webpack --mode=production</code>，可以看到 app.js 只有 4K 不到的大小了，因此我们可以愉快地使用 lodash 了。</p><p>这里的环境是指小程序的服务器地址，我们的小程序，在开发时，在测试时，在发布时，所需要访问的服务器地址是不一样的。我们通常区分开发环境、测试环境、预发布环境、生产环境等。</p><p>现在我们来谈谈 mode，它通常被认为和多环境配置有关。</p><blockquote><p>我们在 <strong>tree shaking</strong> 一节中已经对 mode 有所认识。</p></blockquote><p>mode 有三个可能的值，分别是 production, development, none，小程序不能用 development，所以只有 production 和 none 这两个值。</p><p>我们看到 production 和 development 这样的单词时，很容易将它们和生产环境、开发环境关联起来，这很容易造成误解。</p><p>我们除了需要区分环境，实际上还需要区分构建类型(release, debug)。</p><p>我们应该把 mode 看作是构建类型的配置，而不是环境配置。</p><p>构建类型和环境可以相互组合，譬如开发环境的 debug 包，生产环境的 debug 包，生产环境的 release 包等等。</p><p>修改 webpack.config.js 文件</p><pre><code class="hljs diff copyable"><span class="hljs-addition">+ const webpack = require(\'webpack\');</span>\n<span class="hljs-addition">+ const debuggable = process.env.BUILD_TYPE !== \'release\'</span>\nmodule.exports = {\nplugins: [\n<span class="hljs-addition">+     new webpack.EnvironmentPlugin({</span>\n<span class="hljs-addition">+       NODE_ENV: JSON.stringify(process.env.NODE_ENV) || \'development\',</span>\n<span class="hljs-addition">+       BUILD_TYPE: JSON.stringify(process.env.BUILD_TYPE) || \'debug\',</span>\n<span class="hljs-addition">+     }),</span>\n],\n<span class="hljs-deletion">-   mode: \'none\',</span>\n<span class="hljs-addition">+   mode: debuggable ? \'none\' : \'production\',</span>\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>默认情况下，webpack 会帮我们把 <code>process.env.NODE_ENV</code> 的值设置成 mode 的值</p><p>我们在代码中，可以通过以下方式读取这些环境变量</p><pre><code class="hljs js copyable"><span class="hljs-built_in">console</span>.log(<span class="hljs-string"><code>环境：&lt;span class=&quot;hljs-subst&quot;&gt;${process.env.NODE_ENV}&lt;/span&gt; 构建类型：&lt;span class=&quot;hljs-subst&quot;&gt;${process.env.BUILD_TYPE}&lt;/span&gt;</code></span>)\n<span class="copy-code-btn">复制代码</span></code></pre><p>我们如何注入 <code>NODE_ENV</code> 这些变量的值呢？我们借助 npm scripts 来实现。webpack 官方文档也有关于 npm scripts 的介绍，建议<a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.docschina.org%2Fguides%2Fgetting-started%2F%23npm-scripts" rel="nofollow noopener noreferrer">读一读</a>。</p><p>首先安装</p><pre><code class="hljs bash copyable">npm i --save-dev cross-env\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 package.json 文件，添加 scripts</p><pre><code class="hljs json copyable">{\n<span class="hljs-attr">&quot;scripts&quot;</span>: {\n<span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack --watch --progress&quot;</span>,\n<span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=production BUILD_TYPE=release webpack&quot;</span>\n}\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>现在，可以使用 <code>npm run build</code> 命令，来替代我们之前使用的 <code>npx webpack --mode=production</code> 命令。</p><p>使用 <code>npm start</code> 来替代我们之前使用的 <code>npx webpack --watch --progress</code> 命令。</p><p>修改 webpack.config.js 文件</p><pre><code class="hljs diff copyable">  mode: debuggable ? \'none\' : \'production\',\n<span class="hljs-addition">+ devtool: debuggable ? \'inline-source-map\' : \'source-map\',</span>\n<span class="copy-code-btn">复制代码</span></code></pre><h2 class="heading">支持 Sass</h2><p>安装相关依赖</p><pre><code class="hljs bash copyable">npm i --save-dev sass-loader node-sass file-loader\n<span class="copy-code-btn">复制代码</span></code></pre><p>修改 webpack.config.js 文件</p><pre><code class="hljs diff copyable">module.exports = {\nmodule: {\nrules: [\n<span class="hljs-addition">+       {</span>\n<span class="hljs-addition">+         test: /.(scss)$/,</span>\n<span class="hljs-addition">+         include: /src/,</span>\n<span class="hljs-addition">+         use: [</span>\n<span class="hljs-addition">+           {</span>\n<span class="hljs-addition">+             loader: \'file-loader\',</span>\n<span class="hljs-addition">+             options: {</span>\n<span class="hljs-addition">+               useRelativePath: true,</span>\n<span class="hljs-addition">+               name: \'[path][name].wxss\',</span>\n<span class="hljs-addition">+               context: resolve(\'src\'),</span>\n<span class="hljs-addition">+             },</span>\n<span class="hljs-addition">+           },</span>\n<span class="hljs-addition">+           {</span>\n<span class="hljs-addition">+             loader: \'sass-loader\',</span>\n<span class="hljs-addition">+             options: {</span>\n<span class="hljs-addition">+               includePaths: [resolve(\'src\', \'styles\'), resolve(\'src\')],</span>\n<span class="hljs-addition">+             },</span>\n<span class="hljs-addition">+           },</span>\n<span class="hljs-addition">+         ],</span>\n<span class="hljs-addition">+       },</span>\n],\n},\nplugins: [\nnew CopyWebpackPlugin([\n{\nfrom: \'<strong>/*\',\nto: \'./\',\n<span class="hljs-deletion">-       ignore: [\'</strong>/<em>.js\', ],</span>\n<span class="hljs-addition">+       ignore: [\'**/</em>.js\', \'**/*.scss\'],</span>\n},\n]),\nnew MinaWebpackPlugin({\n<span class="hljs-addition">+      scriptExtensions: [\'.js\'],</span>\n<span class="hljs-addition">+      assetExtensions: [\'.scss\'],</span>\n}),\n],\n}\n<span class="copy-code-btn">复制代码</span></code></pre><p>我们在分析 webpack 工作流程时，曾经提到过，loader 主要工作在 module 构建阶段。也就是说，我们依然需要添加 .scss 文件作为 entry，让 loader 能有机会去解析它，并输出最终结果。</p><p>每一个 entry 都会对应一个 chunk, 每一个 entry chunk 都会输出一个文件。因为 file-loader 已经帮助我们输出最终我们想要的结果了，所以我们需要阻止这一行为。</p><p>修改 plugin/MinaWebpackPlugin.js 文件，以下是修改后的样子</p><pre><code class="hljs js copyable">\n<span class="hljs-keyword">const</span> SingleEntryPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack/lib/SingleEntryPlugin\'</span>)\n<span class="hljs-keyword">const</span> MultiEntryPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'webpack/lib/MultiEntryPlugin\'</span>)\n<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n<span class="hljs-keyword">const</span> replaceExt = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'replace-ext\'</span>)</p>\n<p><span class="hljs-keyword">const</span> assetsChunkName = <span class="hljs-string">\'<strong>assets_chunk_name</strong>\'</span></p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">itemToPlugin</span>(<span class="hljs-params">context, item, name</span>) </span>{\n<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) {\n<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiEntryPlugin(context, item, name)\n}\n<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SingleEntryPlugin(context, item, name)\n}</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inflateEntries</span>(<span class="hljs-params">entries = [], dirname, entry</span>) </span>{\n<span class="hljs-keyword">const</span> configFile = replaceExt(entry, <span class="hljs-string">\'.json\'</span>)\n<span class="hljs-keyword">const</span> content = fs.readFileSync(configFile, <span class="hljs-string">\'utf8\'</span>)\n<span class="hljs-keyword">const</span> config = <span class="hljs-built_in">JSON</span>.parse(content)</p>\n<p>;[<span class="hljs-string">\'pages\'</span>, <span class="hljs-string">\'usingComponents\'</span>].forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {\n<span class="hljs-keyword">const</span> items = config[key]\n<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> items === <span class="hljs-string">\'object\'</span>) {\n<span class="hljs-built_in">Object</span>.values(items).forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> inflateEntries(entries, dirname, item))\n}\n})\n}</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inflateEntries</span>(<span class="hljs-params">entries, dirname, entry</span>) </span>{\nentry = path.resolve(dirname, entry)\n<span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span> &amp;&amp; !entries.includes(entry)) {\nentries.push(entry)\n_inflateEntries(entries, path.dirname(entry), entry)\n}\n}</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params">entry, extensions</span>) </span>{\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ext <span class="hljs-keyword">of</span> extensions) {\n<span class="hljs-keyword">const</span> file = replaceExt(entry, ext)\n<span class="hljs-keyword">if</span> (fs.existsSync(file)) {\n<span class="hljs-keyword">return</span> file\n}\n}\n<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>\n}</p>\n<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">all</span>(<span class="hljs-params">entry, extensions</span>) </span>{\n<span class="hljs-keyword">const</span> items = []\n<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> ext <span class="hljs-keyword">of</span> extensions) {\n<span class="hljs-keyword">const</span> file = replaceExt(entry, ext)\n<span class="hljs-keyword">if</span> (fs.existsSync(file)) {\nitems.push(file)\n}\n}\n<span class="hljs-keyword">return</span> items\n}</p>\n<p><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinaWebpackPlugin</span> </span>{\n<span class="hljs-keyword">constructor</span>(options = {}) {\n<span class="hljs-keyword">this</span>.scriptExtensions = options.scriptExtensions || [<span class="hljs-string">\'.ts\'</span>, <span class="hljs-string">\'.js\'</span>]\n<span class="hljs-keyword">this</span>.assetExtensions = options.assetExtensions || []\n<span class="hljs-keyword">this</span>.entries = []\n}</p>\n<p>applyEntry(compiler, done) {\n<span class="hljs-keyword">const</span> { context } = compiler.options</p>\n<pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.entries\n  .map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;item&lt;/span&gt; =&gt;&lt;/span&gt; first(item, &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.scriptExtensions))\n  .map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;item&lt;/span&gt; =&gt;&lt;/span&gt; path.relative(context, item))\n  .forEach(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;item&lt;/span&gt; =&gt;&lt;/span&gt; itemToPlugin(context, &lt;span class=&quot;hljs-string&quot;&gt;\'./\'&lt;/span&gt; + item, replaceExt(item, &lt;span class=&quot;hljs-string&quot;&gt;\'\'&lt;/span&gt;)).apply(compiler))\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; assets = &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.entries\n  .reduce(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;items, item&lt;/span&gt;) =&gt;&lt;/span&gt; [...items, ...all(item, &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.assetExtensions)], [])\n  .map(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-params&quot;&gt;item&lt;/span&gt; =&gt;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;\'./\'&lt;/span&gt; + path.relative(context, item))\nitemToPlugin(context, assets, assetsChunkName).apply(compiler)\n\n&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (done) {\n  done()\n}\n</code></pre>\n<p>}</p>\n<p>apply(compiler) {\n<span class="hljs-keyword">const</span> { context, entry } = compiler.options\ninflateEntries(<span class="hljs-keyword">this</span>.entries, context, entry)</p>\n<pre><code>compiler.hooks.entryOption.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, () =&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.applyEntry(compiler)\n  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;\n})\n\ncompiler.hooks.watchRun.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, (compiler, done) =&gt; {\n  &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.applyEntry(compiler, done)\n})\n\ncompiler.hooks.compilation.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, compilation =&gt; {\n\n  compilation.hooks.beforeChunkAssets.tap(&lt;span class=&quot;hljs-string&quot;&gt;\'MinaWebpackPlugin\'&lt;/span&gt;, () =&gt; {\n    &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; assetsChunkIndex = compilation.chunks.findIndex(&lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;{ name }&lt;/span&gt;) =&gt;&lt;/span&gt; name === assetsChunkName)\n    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (assetsChunkIndex &gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;) {\n\n      compilation.chunks.splice(assetsChunkIndex, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)\n    }\n  })\n})\n</code></pre>\n<p>}\n}</p>\n<p><span class="hljs-built_in">module</span>.exports = MinaWebpackPlugin\n<span class="copy-code-btn">复制代码</span></code></pre><h2 class="heading">感谢以下项目以及文章</h2>')]),s._v("``")])])},[],!1,null,null,null);l.options.__file="miniapp-webpack.md";n.default=l.exports}}]);