(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{468:function(t,s,n){"use strict";n.r(s);var a=n(24),v=Object(a.a)({},function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"简述【执行上下文】上"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简述【执行上下文】上","aria-hidden":"true"}},[t._v("#")]),t._v(" 简述【执行上下文】上")]),t._v(" "),n("p",[t._v('什么是"执行上下文"（也叫做"执行上下文环境"）？暂且不下定义，先看一段代码：')]),t._v(" "),n("p",[n("img",{attrs:{src:"/my-blog/closure/221743466231490.png",alt:""}})]),t._v(" "),n("p",[t._v("第一句报错，a未定义，很正常。第二句、第三句输出都是"),n("code",[t._v("undefined")]),t._v("，说明浏览器在执行"),n("code",[t._v("console.log(a)")]),t._v("时，已经知道了a是"),n("code",[t._v("undefined")]),t._v("，但却不知道a是10（第三句中）。")]),t._v(" "),n("p",[t._v('在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些"准备工作"，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：')]),t._v(" "),n("p",[n("img",{attrs:{src:"/my-blog/closure/221744084828533.png",alt:""}})]),t._v(" "),n("p",[t._v("这是第一种情况。")]),t._v(" "),n("p",[t._v("下面还有。先来个简单的。")]),t._v(" "),n("p",[n("img",{attrs:{src:"/my-blog/closure/221744319354566.png",alt:""}})]),t._v(" "),n("p",[t._v("有js开发经验的朋友应该都知道，你无论在哪个位置获取"),n("code",[t._v("this")]),t._v("，都是有值的。至于"),n("code",[t._v("this")]),t._v("的取值情况，比较复杂，会专门拿出一篇文章来讲解。")]),t._v(" "),n("p",[t._v("与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给"),n("code",[t._v("this")]),t._v('赋值。这也是"准备工作"情况要做的事情之一。')]),t._v(" "),n("p",[t._v("下面还有。。。第三种情况。")]),t._v(" "),n("p",[t._v('在第三种情况中，需要注意代码注释中的两个名词——"函数表达式"和"函数声明"。虽然两者都很常用，但是这两者在"准备工作"时，却是两种待遇。')]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function(){}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("f1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数声明")]),t._v("\n\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("f2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数表达式")]),t._v("\n")])])]),n("p",[t._v('看以上代码。"函数声明"时我们看到了第二种情况的影子，而"函数表达式"时我们看到了第一种情况的影子。')]),t._v(" "),n("p",[t._v('没错。在"准备工作"中，对待函数表达式就像对待'),n("code",[t._v("var a = 10")]),t._v("这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。")]),t._v(" "),n("p",[t._v('好了，"准备工作"介绍完毕。')]),t._v(" "),n("p",[t._v('我们总结一下，在"准备工作"中完成了哪些工作：')]),t._v(" "),n("ul",[n("li",[t._v("变量、函数表达式——变量声明，默认赋值为"),n("code",[t._v("undefined")]),t._v("；")]),t._v(" "),n("li",[n("code",[t._v("this")]),t._v("——赋值；")]),t._v(" "),n("li",[t._v("函数声明——赋值；")])]),t._v(" "),n("p",[t._v('这三种数据的准备情况我们称之为"执行上下文"或者"执行上下文环境"。')]),t._v(" "),n("p",[t._v("这里插一句题外话：通过以上三种情况，你可能会联想到网上的有些考js语法的题目/面试题。的确，几乎每个js语法题中都有这种题目出现。之前你遇到这种题目是不是靠背诵来解决？背过了，隔几天又忘记了。——任何问题，都要去追根溯源，要知道这个问题是真正出自哪一块知识点，要真正去理解。光靠背诵是没用的。")]),t._v(" "),n("p",[t._v("细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。")]),t._v(" "),n("p",[t._v("其实，"),n("code",[t._v("javascript")]),t._v('在执行一个代码段之前，都会进行这些"准备工作"来生成执行上下文。这个"代码段"其实分三种情况——全局代码，函数体，eval代码。')]),t._v(" "),n("p",[t._v("这里解释一下为什么代码段分为这三种。")]),t._v(" "),n("p",[t._v('所谓"代码段"就是一段文本形式的代码。')]),t._v(" "),n("p",[t._v("首先，全局代码是一种，这个应该没有非议，本来就是手写文本到")])])},[],!1,null,null,null);v.options.__file="closure-8.md";s.default=v.exports}}]);