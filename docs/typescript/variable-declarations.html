<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>变量声明 | songStar</title>
    <meta name="description" content="let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。">
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no">
  <link rel="icon" href="logo.jpg">
    
    <link rel="preload" href="/my-blog/assets/css/0.styles.225419fd.css" as="style"><link rel="preload" href="/my-blog/assets/js/app.6f5c8bb9.js" as="script"><link rel="preload" href="/my-blog/assets/js/6.db6760d0.js" as="script"><link rel="preload" href="/my-blog/assets/js/97.5864c00a.js" as="script"><link rel="prefetch" href="/my-blog/assets/js/10.76acdb26.js"><link rel="prefetch" href="/my-blog/assets/js/11.cca66d9f.js"><link rel="prefetch" href="/my-blog/assets/js/12.759a21b8.js"><link rel="prefetch" href="/my-blog/assets/js/13.71240dad.js"><link rel="prefetch" href="/my-blog/assets/js/14.3e929357.js"><link rel="prefetch" href="/my-blog/assets/js/15.2fad725c.js"><link rel="prefetch" href="/my-blog/assets/js/16.01ac80fa.js"><link rel="prefetch" href="/my-blog/assets/js/17.ec39746b.js"><link rel="prefetch" href="/my-blog/assets/js/18.3462ff9b.js"><link rel="prefetch" href="/my-blog/assets/js/19.d23fb828.js"><link rel="prefetch" href="/my-blog/assets/js/2.ed1d4fc5.js"><link rel="prefetch" href="/my-blog/assets/js/20.d777a6dd.js"><link rel="prefetch" href="/my-blog/assets/js/21.85e9497b.js"><link rel="prefetch" href="/my-blog/assets/js/22.3086070e.js"><link rel="prefetch" href="/my-blog/assets/js/23.18712e24.js"><link rel="prefetch" href="/my-blog/assets/js/24.50db803a.js"><link rel="prefetch" href="/my-blog/assets/js/25.3babe4f2.js"><link rel="prefetch" href="/my-blog/assets/js/26.33214df5.js"><link rel="prefetch" href="/my-blog/assets/js/27.941545f4.js"><link rel="prefetch" href="/my-blog/assets/js/28.a4f9172f.js"><link rel="prefetch" href="/my-blog/assets/js/29.09d59d5f.js"><link rel="prefetch" href="/my-blog/assets/js/3.81f24e3d.js"><link rel="prefetch" href="/my-blog/assets/js/30.b32e6e85.js"><link rel="prefetch" href="/my-blog/assets/js/31.c90e08e3.js"><link rel="prefetch" href="/my-blog/assets/js/32.df203f3f.js"><link rel="prefetch" href="/my-blog/assets/js/33.14982719.js"><link rel="prefetch" href="/my-blog/assets/js/34.60f9bcf7.js"><link rel="prefetch" href="/my-blog/assets/js/35.5d83c85e.js"><link rel="prefetch" href="/my-blog/assets/js/36.9e06c928.js"><link rel="prefetch" href="/my-blog/assets/js/37.99c45a44.js"><link rel="prefetch" href="/my-blog/assets/js/38.0e0a0c85.js"><link rel="prefetch" href="/my-blog/assets/js/39.a53ab6d8.js"><link rel="prefetch" href="/my-blog/assets/js/4.a9d4f632.js"><link rel="prefetch" href="/my-blog/assets/js/40.81111213.js"><link rel="prefetch" href="/my-blog/assets/js/41.064d4dda.js"><link rel="prefetch" href="/my-blog/assets/js/42.7ac7d5f4.js"><link rel="prefetch" href="/my-blog/assets/js/43.a1d4fa2f.js"><link rel="prefetch" href="/my-blog/assets/js/44.90b50722.js"><link rel="prefetch" href="/my-blog/assets/js/45.efe88135.js"><link rel="prefetch" href="/my-blog/assets/js/46.99277489.js"><link rel="prefetch" href="/my-blog/assets/js/47.97b8a110.js"><link rel="prefetch" href="/my-blog/assets/js/48.548ff248.js"><link rel="prefetch" href="/my-blog/assets/js/49.ed1bdd61.js"><link rel="prefetch" href="/my-blog/assets/js/5.38649c44.js"><link rel="prefetch" href="/my-blog/assets/js/50.131dc1fc.js"><link rel="prefetch" href="/my-blog/assets/js/51.6bce2a3d.js"><link rel="prefetch" href="/my-blog/assets/js/52.04f40294.js"><link rel="prefetch" href="/my-blog/assets/js/53.f22df6a6.js"><link rel="prefetch" href="/my-blog/assets/js/54.e1e6b171.js"><link rel="prefetch" href="/my-blog/assets/js/55.a0a9a795.js"><link rel="prefetch" href="/my-blog/assets/js/56.3b8f35c1.js"><link rel="prefetch" href="/my-blog/assets/js/57.d127d6a2.js"><link rel="prefetch" href="/my-blog/assets/js/58.2669bd52.js"><link rel="prefetch" href="/my-blog/assets/js/59.707216c9.js"><link rel="prefetch" href="/my-blog/assets/js/60.ed864a57.js"><link rel="prefetch" href="/my-blog/assets/js/61.b0070c6b.js"><link rel="prefetch" href="/my-blog/assets/js/62.6d12de70.js"><link rel="prefetch" href="/my-blog/assets/js/63.228e87ba.js"><link rel="prefetch" href="/my-blog/assets/js/64.6638b77c.js"><link rel="prefetch" href="/my-blog/assets/js/65.86a870cd.js"><link rel="prefetch" href="/my-blog/assets/js/66.8e3b2f02.js"><link rel="prefetch" href="/my-blog/assets/js/67.7098cfbe.js"><link rel="prefetch" href="/my-blog/assets/js/68.816e8f09.js"><link rel="prefetch" href="/my-blog/assets/js/69.bb570e28.js"><link rel="prefetch" href="/my-blog/assets/js/7.080dc08a.js"><link rel="prefetch" href="/my-blog/assets/js/70.663077f6.js"><link rel="prefetch" href="/my-blog/assets/js/71.3ff5ad97.js"><link rel="prefetch" href="/my-blog/assets/js/72.6d692237.js"><link rel="prefetch" href="/my-blog/assets/js/73.b41e2105.js"><link rel="prefetch" href="/my-blog/assets/js/74.c52153f5.js"><link rel="prefetch" href="/my-blog/assets/js/75.b3fa1f88.js"><link rel="prefetch" href="/my-blog/assets/js/76.af86a832.js"><link rel="prefetch" href="/my-blog/assets/js/77.96af3f86.js"><link rel="prefetch" href="/my-blog/assets/js/78.af269b97.js"><link rel="prefetch" href="/my-blog/assets/js/79.c7ac8b7a.js"><link rel="prefetch" href="/my-blog/assets/js/8.03aa855e.js"><link rel="prefetch" href="/my-blog/assets/js/80.b2a67c50.js"><link rel="prefetch" href="/my-blog/assets/js/81.39a98ec1.js"><link rel="prefetch" href="/my-blog/assets/js/82.0f0f73da.js"><link rel="prefetch" href="/my-blog/assets/js/83.c657e414.js"><link rel="prefetch" href="/my-blog/assets/js/84.6160ddcf.js"><link rel="prefetch" href="/my-blog/assets/js/85.fe595fca.js"><link rel="prefetch" href="/my-blog/assets/js/86.5cf766f6.js"><link rel="prefetch" href="/my-blog/assets/js/87.824d0aee.js"><link rel="prefetch" href="/my-blog/assets/js/88.e384b9b8.js"><link rel="prefetch" href="/my-blog/assets/js/89.cee945c5.js"><link rel="prefetch" href="/my-blog/assets/js/9.0e80f474.js"><link rel="prefetch" href="/my-blog/assets/js/90.f991f5a2.js"><link rel="prefetch" href="/my-blog/assets/js/91.e3a90819.js"><link rel="prefetch" href="/my-blog/assets/js/92.56dafd0e.js"><link rel="prefetch" href="/my-blog/assets/js/93.133459e1.js"><link rel="prefetch" href="/my-blog/assets/js/94.aa5e8b15.js"><link rel="prefetch" href="/my-blog/assets/js/95.7f50c8cc.js"><link rel="prefetch" href="/my-blog/assets/js/96.f45dd01b.js"><link rel="prefetch" href="/my-blog/assets/js/98.f6667f4f.js"><link rel="prefetch" href="/my-blog/assets/js/99.3f7e78e4.js">
    <link rel="stylesheet" href="/my-blog/assets/css/0.styles.225419fd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="page-main"><header class="component-nav-menu nav-bar"><i class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></i> <div class="title">songStar</div> <div class="search-wrapper"><div aria-haspopup="listbox" role="combobox" aria-owns="el-autocomplete-3340" class="el-autocomplete search-input no-focused"><div class="el-input el-input--prefix"><!----><input type="text" autocomplete="off" valueKey="title" placeholder="请输入内容" fetchSuggestions="function () { [native code] }" triggerOnFocus="true" debounce="300" placement="bottom-start" popperAppendToBody="true" background-color="#eee" value="" class="el-input__inner"><span class="el-input__prefix"><i class="el-input__icon el-icon-search"></i></span><!----><!----></div><div role="region" class="el-autocomplete-suggestion el-popper" style="width:;display:none;"><div class="el-scrollbar"><div class="el-autocomplete-suggestion__wrap el-scrollbar__wrap el-scrollbar__wrap--hidden-default"><ul class="el-scrollbar__view el-autocomplete-suggestion__list"></ul></div><div class="el-scrollbar__bar is-horizontal"><div class="el-scrollbar__thumb" style="width:0;transform:translateX(0%);ms-transform:translateX(0%);webkit-transform:translateX(0%);"></div></div><div class="el-scrollbar__bar is-vertical"><div class="el-scrollbar__thumb" style="height:0;transform:translateY(0%);ms-transform:translateY(0%);webkit-transform:translateY(0%);"></div></div></div></div></div></div> <div class="sidebar-mask" style="display:none;"></div> <ul role="menubar" class="el-menu--horizontal el-menu nav-links" style="background-color:;"><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Home
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Blog
      </li><li role="menuitem" aria-haspopup="true" class="el-submenu"><div class="el-submenu__title" style="border-bottom-color:transparent;color:;background-color:;">
          docs
        <i class="el-submenu__icon-arrow el-icon-arrow-down"></i></div><div class="el-menu--horizontal" style="display:none;"><ul role="menu" class="el-menu el-menu--popup el-menu--popup-" style="background-color:;"> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;">
          es6
        </li><li role="menuitem" tabindex="-1" class="el-menu-item is-active" style="color:;background-color:;">
          typescript
        </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;">
          closure
        </li></ul></div></li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        About
      </li><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;">
        Github
      </li></ul></header> <!----> <div class="page-container"><div class="component-page"><div class="page-content"><!----> <div class="content default"><h1 id="变量声明"><a href="#变量声明" aria-hidden="true" class="header-anchor">#</a> 变量声明</h1> <p><code>let</code>和 <code>const</code>是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， <code>let</code>在很多方面与 <code>var</code>是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 <code>const</code>是对 <code>let</code>的一个增强，它能阻止对一个变量再次赋值。</p> <p>因为TypeScript是JavaScript的超集，所以它本身就支持 <code>let</code>和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p> <p>如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 <code>var</code>声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p> <p>一直以来我们都是通过 <code>var</code>关键字定义JavaScript变量。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>大家都能理解，这里定义了一个名为 <code>a</code>值为 <code>10</code>的变量。</p> <p>我们也可以在函数内部定义变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> message<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并且我们也可以在其它函数内部访问相同的变量。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 11;</span>
</code></pre></div><p>上面的例子里， <code>g</code>可以获取到 <code>f</code>函数里定义的 <code>a</code>变量。 每当 <code>g</code>被调用时，它都可以访问到 <code>f</code>里的 <code>a</code>变量。 即使当 <code>g</code>在 <code>f</code>已经执行完后才被调用，它仍然可以访问及修改 <code>a</code>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> b<span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 2</span>
</code></pre></div><h2 id="作用域规则"><a href="#作用域规则" aria-hidden="true" class="header-anchor">#</a> 作用域规则</h2> <p>对于熟悉其它语言的人来说， <code>var</code>声明有些奇怪的作用域规则。 看下面的例子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>shouldInitialize<span class="token punctuation">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldInitialize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// returns '10'</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 'undefined'</span>
</code></pre></div><p>有些读者可能要多看几遍这个例子。 变量 <code>x</code>是定义在* <code>if</code>语句里面*，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code>声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* <code>var</code>作用域 _或_函数作用域*。 函数参数也使用函数作用域。</p> <p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span>matrix<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里很容易看出一些问题，里层的 <code>for</code>循环会覆盖变量 <code>i</code>，因为所有 <code>i</code>都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p> <h2 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" aria-hidden="true" class="header-anchor">#</a> 捕获变量怪异之处</h2> <p>快速的猜一下下面的代码会返回什么：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>介绍一下， <code>setTimeout</code>会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p> <p>好吧，看一下结果：</p> <div class="language-text extra-class"><pre class="language-text"><code>10
10
10
10
10
10
10
10
10
10
</code></pre></div><p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p> <div class="language-text extra-class"><pre class="language-text"><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div><p>还记得我们上面提到的捕获变量吗？</p> <blockquote><p>我们传给 <code>setTimeout</code>的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p></blockquote> <p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code>在若干毫秒后执行一个函数，并且是在 <code>for</code>循环结束后。 <code>for</code>循环结束后， <code>i</code>的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>！</p> <p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code>的值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// capture the current state of 'i'</span>
    <span class="token comment">// by invoking a function with its current value</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code>会覆盖 <code>for</code>循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code>循环体里的代码。</p> <p>现在你已经知道了 <code>var</code>存在一些问题，这恰好说明了为什么用 <code>let</code>语句来声明变量。 除了名字不同外， <code>let</code>与 <code>var</code>的写法一致。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p> <h2 id="块作用域"><a href="#块作用域" aria-hidden="true" class="header-anchor">#</a> 块作用域</h2> <p>当用 <code>let</code>声明一个变量，它使用的是 _词法作用域_或 <em>块作用域</em>。 不同于使用 <code>var</code>声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code>循环之外是不能访问的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>input<span class="token punctuation">:</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Still okay to reference 'a'</span>
        <span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Error: 'b' doesn't exist here</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们定义了2个变量 <code>a</code>和 <code>b</code>。 <code>a</code>的作用域是 <code>f</code>函数体内，而 <code>b</code>的作用域是 <code>if</code>语句块里。</p> <p>在 <code>catch</code>语句里声明的变量也具有同样的作用域规则。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">&quot;oh no!&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Oh well.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error: 'e' doesn't exist here</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终&quot;存在&quot;于它们的作用域里，但在直到声明它的代码之前的区域都属于 <em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code>语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// illegal to use 'a' before it's declared;</span>
<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前 _获取_它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// okay to capture 'a'</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 不能在'a'被声明前调用'foo'</span>
<span class="token comment">// 运行时应该抛出错误</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a<span class="token punctuation">;</span>
</code></pre></div><h2 id="重定义及屏蔽"><a href="#重定义及屏蔽" aria-hidden="true" class="header-anchor">#</a> 重定义及屏蔽</h2> <p>我们提过使用 <code>var</code>声明时，它不在乎你声明多少次；你只会得到1个。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子里，所有 <code>x</code>的声明实际上都引用一个 _相同_的 <code>x</code>，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， <code>let</code>声明就不会这么宽松了。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// 错误，不能在1个作用域里多次声明`x`</span>
</code></pre></div><p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: interferes with parameter declaration</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// error: can't have both declarations of 'x'</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>condition<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// returns 100</span>
</code></pre></div><p>在一个嵌套作用域里引入一个新名字的行为称做 <em>屏蔽</em>。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code>重写之前的 <code>sumMatrix</code>函数。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span>matrix<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code>可以屏蔽掉外层循环的 <code>i</code>。</p> <p>_通常_来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p> <h2 id="块级作用域变量的获取"><a href="#块级作用域变量的获取" aria-hidden="true" class="header-anchor">#</a> 块级作用域变量的获取</h2> <p>在我们最初谈及获取用 <code>var</code>声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 <em>环境</em>。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">theCityThatAlwaysSleeps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> getCity<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> city <span class="token operator">=</span> <span class="token string">&quot;Seattle&quot;</span><span class="token punctuation">;</span>
        <span class="token function-variable function">getCity</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为我们已经在 <code>city</code>的环境里获取到了 <code>city</code>，所以就算 <code>if</code>语句执行结束后我们仍然可以访问它。</p> <p>回想一下前面 <code>setTimeout</code>的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code>循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p> <p>当 <code>let</code>声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 _每次迭代_都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 <code>setTimeout</code>例子里我们仅使用 <code>let</code>声明就可以了。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会输出与预料一致的结果：</p> <div class="language-text extra-class"><pre class="language-text"><code>0
1
2
3
4
5
6
7
8
9
</code></pre></div><p><code>const</code> 声明是声明变量的另一种方式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
</code></pre></div><p>它们与 <code>let</code>声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code>相同的作用域规则，但是不能对它们重新赋值。</p> <p>这很好理解，它们引用的值是 <em>不可变的</em>。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&quot;Aurora&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token punctuation">:</span> numLivesForCat<span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error</span>
kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">&quot;Danielle&quot;</span><span class="token punctuation">,</span>
    numLives<span class="token punctuation">:</span> numLivesForCat
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// all &quot;okay&quot;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Rory&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Kitty&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Cat&quot;</span><span class="token punctuation">;</span>
kitty<span class="token punctuation">.</span>numLives<span class="token operator">--</span><span class="token punctuation">;</span>
</code></pre></div><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p> <p>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener noreferrer">最小特权原则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 <code>const</code>也可以让我们更容易的推测数据的流动。</p> <p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p> <p>这个手册大部分地方都使用了 <code>let</code>声明。</p> <h2 id="解构数组"><a href="#解构数组" aria-hidden="true" class="header-anchor">#</a> 解构数组</h2> <p>最简单的解构莫过于数组的解构赋值了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> input<span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 2</span>
</code></pre></div><p>这创建了2个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>first <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
second <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>解构作用于已声明的变量会更好：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// swap variables</span>
<span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>second<span class="token punctuation">,</span> first<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>作用于函数参数：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以在数组里使用 <code>...</code>语法创建剩余变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs [ 2, 3, 4 ]</span>
</code></pre></div><p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// outputs 1</span>
</code></pre></div><p>或其它元素：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> <span class="token punctuation">,</span> fourth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="对象解构"><a href="#对象解构" aria-hidden="true" class="header-anchor">#</a> 对象解构</h2> <p>你也可以解构对象：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> <span class="token string">&quot;bar&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这通过 <code>o.a</code> and <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p> <p>就像数组解构，你可以用没有声明的赋值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">101</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 <code>{</code> 起始的语句解析为一个块。</p> <p>你可以在对象里使用 <code>...</code>语法创建剩余变量：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>passthrough <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
<span class="token keyword">let</span> total <span class="token operator">=</span> passthrough<span class="token punctuation">.</span>b <span class="token operator">+</span> passthrough<span class="token punctuation">.</span>c<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

</code></pre></div><p>你也可以给属性以不同的名字：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> newName1<span class="token punctuation">,</span> b<span class="token punctuation">:</span> newName2 <span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 &quot; <code>a</code> 作为 <code>newName1</code>&quot;。 方向是从左到右，好像你写成了以下样子：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> newName1 <span class="token operator">=</span> o<span class="token punctuation">.</span>a<span class="token punctuation">;</span>
<span class="token keyword">let</span> newName2 <span class="token operator">=</span> o<span class="token punctuation">.</span>b<span class="token punctuation">;</span>
</code></pre></div><p>令人困惑的是，这里的冒号 _不是_指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>默认值可以让你在属性为 undefined 时使用缺省值：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">keepWholeObject</span><span class="token punctuation">(</span>wholeObject<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">}</span> <span class="token operator">=</span> wholeObject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，即使 <code>b</code> 为 undefined ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p> <h2 id="函数声明"><a href="#函数声明" aria-hidden="true" class="header-anchor">#</a> 函数声明</h2> <p>解构也能用于函数声明。 看以下简单的情况：</p> <p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">=</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>

<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p></blockquote> <p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>

<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">&quot;yes&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, default to {a: &quot;&quot;}, which then defaults b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error, 'a' is required if you supply an argument</span>
</code></pre></div><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p> <p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bothPlus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>second<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这会令 <code>bothPlus</code>的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code>和 <code>second</code>的一份浅拷贝。 它们不会被展开操作所改变。</p> <p>你还可以展开对象：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>defaults<span class="token punctuation">,</span> food<span class="token punctuation">:</span> <span class="token string">&quot;rich&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>search</code>的值为 <code>{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;spicy&quot;</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">&quot;$$&quot;</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">&quot;noisy&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">&quot;rich&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span>defaults <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>那么， <code>defaults</code>里的 <code>food</code>属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
  p <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> clone <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>c <span class="token punctuation">}</span><span class="token punctuation">;</span>
clone<span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token comment">// ok</span>
clone<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error!</span>

</code></pre></div><p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p></div> <div class="page-nav"><div class="pre"><!----></div> <div class="next"><!----></div></div> <div class="vcomment content"><div id="vcomments"></div></div></div> <!----></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/my-blog/assets/js/app.6f5c8bb9.js" defer></script><script src="/my-blog/assets/js/6.db6760d0.js" defer></script><script src="/my-blog/assets/js/97.5864c00a.js" defer></script>
  </body>
</html>
